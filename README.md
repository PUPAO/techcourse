목차:
1. 동기
2. 아키텍처 구조
3. 웹 통신 방식을 WebSocket으로 선택한 이유
4. GCP & Netlify 선택 이유
5. 백엔드 및 이미지 저장소 기술 선택 이유
6. 모노레포지토리를 선택한 이유
7. 게임 흐름 설계
8. 핵심 기능 정의

일단 주소를 먼저 알려드리겠습니다.

https://sweet-syrniki-946944.netlify.app/


### 동기

알바를 하다거나 공부를 하다가 쉴 때, 가끔씩 애매하게 남는 시간이 있었는데, 그 시간에 가볍게 즐길 수 있는 게임이 있으면 좋겠다는 생각이 들었습니다.

하지만 일반적인 게임들은 진입장벽이 존재하거나, 막상 시작하면 오래 몰입하게 되어 시간을 많이 쓰게 되는 경우가 많습니다.

그래서 단판으로 빠르게 끝나면서도 재미있는 웹 게임을 만들고자 했습니다.

설치가 필요 없는 웹 기반으로 제작하여 어디서든 접근할 수 있게 구성했습니다.


### 아키텍처 구조
![제목 없는 다이어그램](https://github.com/user-attachments/assets/1979ccbf-e3e5-4933-ae3e-6340f20956df)


### 웹 통신 방식을 WebSocket으로 선택한 이유

처음 조사했던 웹 통신 방식은 다음 네 가지였습니다.

- REST API
- GraphQL
- gRPC
- WebSocket

대부분의 웹 서비스에서 REST API는 워낙 흔하게 사용되기 때문에 이번 프로젝트에서는 오히려 REST API를 사용하지 않기로 결정했습니다.

또한 요청과 응답에 많은 엔드포인트가 생성될 것이라고 예상했기에, 이번 프로젝트에서는 다른 방식에 도전해보고 싶었던 것도 이유 중 하나입니다.

게임이라는 특성상 양방향 통신이 필요하다고 판단하여, WebSocket이 가장 적합하다고 생각했습니다.

또한 WebSocket은 Spring Boot에서 dependencies 추가만으로 비교적 쉽게 구현이 가능해 개발 시간 대비 효율이 높다고 느꼈습니다.


### GCP & Netlify 선택 이유

GCP를 사용한 가장 큰 이유는 무료 크레딧과 비용 안정성입니다.

과거 AWS 프리티어를 사용한 적이 있었지만, 이용 기간 1년이 지나 버려서 무료 혜택이 삭제된 경험이 있습니다.

그 이후로 AWS를 다시 사용하는 데 비용 부담이 생겼습니다.

프론트엔드 배포 플랫폼을 고민하면서 처음에는 Docker로 GCP에 같이 올릴까 고민도 했지만 올해까지는 최대한 비용을 아끼고 싶었고, AWS나 GCP에 대한 경험도 아직 많지 않았기 때문에 정적 웹 호스팅을 무료로 제공하는 Netlify를 선택했습니다.

초기에 고려했던 GCP 기반 프론트 배포 방법:

- Cloud Storage + Load Balancer + CDN
- Cloud Run + Nginx + React

하지만 설정이 복잡하고, 비용이 발생할 가능성이 높아서 이번 프로젝트에서는 제외하기로 결정했습니다.

Netlify는 정적 사이트 배포에 최적화되어 있고 빠르고, 무료이며, 사용하기 쉽다는 점도 큰 장점이었습니다.


### **백엔드 및 이미지 저장소 기술 선택 이유**

백엔드에는 **Spring Boot**를 사용했습니다.

이미 익숙하기도 하고, 이번이 처음 사용해보는 것이지만 WebSocket 기능도 Spring에서 쉽게 적용 가능하다고 생각하고 있었습니다.

또한 Docker로 백엔드를 묶어야 Cloud Run에서 배포할 수 있도록 되어 있어 컨테이너화 과정도 자연스럽게 진행되었습니다.

Docker 이미지 저장소는 GCP Artifact Registry를 선택했습니다.

이유는 Cloud Run와 같이 GCP 내에서 지원해주기 때문에 무료 크레딧으로 사용할 수 있다고 생각합니다.


### **모노레포지토리를 선택한 이유**

프론트엔드와 백엔드의 연결 과정에서 레포지토리를 나누거나, 하나의 레포지토리, 모노레포지토리 등을 사용하는 Git 폴더 구조 문제에 대해 내가 사용하지 못해본, 못할 것 같은 방법에 대해 고민하면서 모노레포지토리를 사용했습니다.

앞으로 다양한 사람들과 협업을 통해 프로젝트를 진행하겠지만, organazation, 하나의 레포지토리에 브랜치를 나눠서 사용하는 방식을 많이 사용할 것으로 예상합니다.


### 게임 흐름 설계

게임은 다음과 같은 단계를 가집니다.

| 계임 단계 | 구현 완료 여부 |
| --- | --- |
| 소셜 로그인을 통해 사용자 인증 | X |
| 첫 로그인 사용자라면 닉네임(게임 내 이름) 등록 | O |
| 로그인 페이지에서 상위 10명의 최고 기록(라운드 수) 및 닉네임 표시 | X |
| React 프론트엔드에서 서버와 WebSocket 연결 생성 | O |
| 서버에 로그인 이벤트(Login Message) 전송 | O |
| 서버가 게임 시작을 의미하는 START 메시지 전송 | O |
| 사용자는 가위 / 바위 / 보 중 하나를 선택하여 PLAY 메시지 전송 | O |
| 서버는 결과 연산 후( 승리 시 라운드 증가(+1) || 패배/무승부 시 변화 없음 ) | O |
| 전진(승리) 또는 정지(패배/무승부) 상황을 클라이언트에 전달 | O |
| 매 라운드마다 히스토리(HISTORY) 로그 누적 | O |
| 사용자가 총 3번 패배하면 게임 종료 → 서버가 FINISH 메시지와 최종 라운드 수 반환 | O |
| 게임 종료 화면에서 기록을 확인하고, “새 게임 시작”을 통해 다시 플레이 가능 | O |


### **핵심 기능 정의**

- 실시간 WebSocket 게임 처리
- 라운드 별 히스토리 제공
- 컴퓨터 랜덤 선택
- 라우드 증가에 따른 시각적 진행 표시 (🚗---💨)
- 종료 후 리뷰 화면 제공
- FE/BE 완전 분리 구조(모노레포 구조)
